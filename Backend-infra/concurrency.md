# 💥 동시성 제어 전략과 실무 설계 사례

📅 작성일: 2025-04-09  
📂 분류: Backend-Infra / Concurrency  
🔖 태그: #동시성 #RaceCondition #분산락 #트랜잭션 #멀티서버 #실무설계

---

## 🔍 동시성 문제란?

여러 스레드(or 프로세스)가 동시에 같은 공유 자원에 접근할 때,

실행 순서에 따라 결과가 달라지거나 데이터가 꼬이는 문제를 말한다.

---

## 🔥 대표적인 예시

- 두 개의 스레드가 동시에 `count++` 수행시 -> 예상과 다른 값
- 하나의 재고 수량을 두 사용자가 동시에 구매 -> 재고 음수
- 한 결제 건에 대해 중복 승인 발생 -> 결제 2번 처리됨

---

## ✅ 동시성 문제의 원인

- 스레드 간 **경쟁 상태**
- 자원 접근에 대한 **순서 보장 없음**
- 멀티 서버 환경에서 **JVM 메모리 격리**

---

## 🛠️ 동시성 해결 전략 요약

| 전략 | 도구/기술 | 설명 |
|------|-----------|------|
| JVM 수준 락 | `synchronized`, `ReentrantLock`, `AtomicInteger` | 단일 서버에서만 유효 |
| 트랜잭션 격리 | DB 트랜잭션, `@Transactional`, `SELECT FOR UPDATE` | DB 내 자원 보호 |
| 분산 락 | Redis 분산 락(Redisson 등) | 멀티 서버 간 자원 충돌 방지 |

---

## 🧩 설계 포인트

- 멀티 서버 환경에서는 `ReentrantLock`, `AtomicInteger`는 서버 간에 의미 없음
- `AtomicInteger`는 **보조적 필터링 용도**로만 활용 가능 (ex. 성능 최적화)
- 진짜 자원 보호는 반드시 Redis 분산 락 또는 트랜잭션 내에서 수행

---

## 💼 실무 적용 사례

### 🛒 선착순 쿠폰 발급 + 결제 시스템

**문제 상황**

쿠폰 수량 한정 상황에서 중복 지급, 중복 결제 상황 발생 가능성

**1차 필터링**

AtomicInteger로 초과 요청 빠르게 거르기 (성능 최적화용)

**2차 동기화**

Redis 락으로 하나의 요청만 결제 확정 처리

**최종 상태 보호**

트랜잭션 내에서 재고 차감 + 주문 상태 변경

-> 결과적으로 실시간 트래픽 상황에서도 중복 처리 없이 안정적인 운영 가능

---