# 📝 # BFS (Breadth-First Search)

📅 작성일: 2025-04-06  
📂 분류: DataStructure / bfs
🔖 태그: #BFS #Queue #탐색 #그래프 #시뮬레이션 #시간비교

---

## 🔍 요약

BFS(너비 우선 탐색)는 그래프나 트리, 2차원 격자 등에서

**가장 가까운 노드부터 차례대로 탐색하는 방식**이다.

**큐(Queue)를 이용하여 구현**하며,

방문 여부를 체크하는 visited 배열과

상하좌우 이동 시의 범위 체크가 핵심이다.

---

## 🧠 BFS의 핵심 개념

- **Queue(큐)**를 사용하여 탐색 순서를 유지
- **가까운 노드부터 먼저 탐색**
- **방문 여부(visisted)**를 기록하여 중복 방문 방지
- **거리나 시간 계산이 필요한 경우**엔 별도의 배열(distance 또는 time)을 사용

---

## 🔁 BFS 기본 흐름 (Queue 기반)

- 시작 노드를 큐에 삽입하고 방문 처리
- 큐가 빌 때까지 반복:
    - 큐에서 노드를 꺼내고
    - 인접한 노드들 중 방문하지 않은 노드를 큐에 넣음
- 인접한 노드는 일반적으로 상하좌우 방향(dx, dy)으로 계산

---

## 🧩 BFS 구현 시 자주 쓰는 요소

**방문 배열**

```java
boolean[] visited = new boolean[n];  // 1차원 그래프
boolean[][] visited = new boolean[n][m];  // 2차원 격자
```

**거리 / 시간 배열**

```java
int[][] distance = new int[n][m];  // 시작점으로부터의 거리
int[][] time = new int[n][m];  // 도착까지 걸린 시간
```

---

## 🚫 BFS 사용 시 주의할 점

- 큐에 넣을 때 반드시 visited 처리를 함께 해야함 (무한루프 방지) - 해당 노드를 방문 했다는 체크
- 인접 노드 탐색 시 범위 체크 필수
- 퍼지는 시뮬레이션 문제에서는 불이나 바이러스등 여러 개체를 따로 큐에 관리해야 할 수 있음
- 여러 주체가 동시에 움직일땐 BFS 순서가 중요 (ex. 불 -> 사람 순서)

---

## 📊 표 형식 비교 (일반 BFS vs 시뮬레이션 기반 BFS)

|항목 |	일반 BFS (미로 등) |	시뮬레이션 BFS (불 문제 등)|
|----|-----------------|--------------------------|
|큐 개수 |	하나 (단일 주체) |	두 개 이상 (불/사람, 바이러스 등)|
|방문 체크 |	visited[x][y] |	visited[x][y], fireTime[x][y] 등|
|시간/거리 계산 방식	distance[x][y] = distance + 1	time[x][y], fireTime[x][y] 따로 계산|
|이동 조건 판단 |	방문 여부만 확인 |	시간 비교 (불보다 먼저 도착 등)|
|종료 조건 |	도착점 도달 여부 |	가장자리 탈출 or 전체 감염 등|
