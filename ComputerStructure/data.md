# ⚙️ 컴퓨터는 숫자와 문자를 어떻게 저장하고 처리하는가?

📅 작성일: 2025-05-23  
📂 분류: ComputerStructure  
🔖 태그: #컴퓨터구조 #데이터 #숫자 #문자

---

## 1. 데이터의 기본 단위: 비트, 바이트, 워드

- **비트(bit)**: 0 또는 1, 정보의 최소 단위  
- **바이트(byte)**: 8비트, 하나의 ASCII 문자나 256개의 값을 표현 가능  
- **워드(word)**: CPU가 한 번에 처리할 수 있는 단위  
  - 예: 32비트 CPU → 1워드 = 32비트, 4바이트
  - 시스템 구조에 따라 메모리 정렬, 주소 단위 등에 영향을 줌

---

## 2. 정수 표현: 2진수 & 16진수

- **2진수**는 컴퓨터의 기본 수 체계  
  - 표현 범위: n비트 → 2ⁿ개의 값 표현 가능
- **16진수(hex)** 는 2진수보다 읽기 쉬워서 디버깅, 메모리 주소 등에서 많이 사용  
  - ex) `0xFF = 255 = 11111111₂`

📌 실무 팁: IP주소, MAC주소, 메모리 덤프 등에서 16진수가 표준처럼 쓰임

---

## 3. 실수 표현: 부동소수점(Floating Point) & IEEE 754

### 🔹 부동소수점이란?
- 소수점 위치가 "부동(floating)"이라는 의미
- 고정소수점보다 훨씬 더 넓은 수 범위를 표현할 수 있음

### 🔹 IEEE 754 표준
- 실수는 다음 3요소로 나뉘어 저장됨:  
  - **Sign(1비트)**: 부호  
  - **Exponent(8비트)**: 지수 + 바이어스  
  - **Mantissa(23비트)**: 가수 (1.xxxx 중 'xxxx'만 저장)

### 🔹 바이어스란?
- Exponent에 offset을 줘서 음수 지수도 표현 가능하게 하는 테크닉
- 8비트 지수 → bias = 2⁷ - 1 = 127

### ⚠ 정밀도 한계
- 0.1, 0.2와 같은 10진 소수는 2진수로 정확히 표현되지 않음 → 근사값 저장됨

```java
public class Floating {
    public static void main(String[] args) {
        double a = 0.1;
        double b = 0.2;
        double c = 0.3;

        if (a + b == c) {
            System.out.println("Equal");
        } else {
            System.out.println("Not Equal");
        }

    }
}
```

오차의 원인: 2진수 표현 시 무한 반복 소수 발생 + 자릿수 제한

📌 실무 팁: 금액, 통화 연산 등 정밀도 요구되는 계산에는 BigDecimal 사용 권장

---

## 4. 문자 표현 : 인코딩과 문자셋

### 🔹 ASCII
초창기 문자 인코딩 (7비트, 총 128문자)

'A' = 65 → 01000001 (2진수)

### 🔹 EUC-KR
한국어 문자 표현을 위해 2바이트 사용

한글 1글자 = 2바이트 (16진수 4자리)

호환성 문제: ASCII는 그대로 쓰고 한글만 2바이트 → 혼용 주의

### 🔹 Base64
바이너리 데이터를 ASCII 문자로 안전하게 인코딩

예: 이미지, 이메일 첨부파일, JWT의 payload 등

3바이트 → 4문자 (64개의 안전한 문자로 매핑)

📌 실무 팁: 네트워크 전송, URL-safe 변환 등에서 필수로 사용됨

---

## 🧠 핵심 정리

|개념|	요약|
|---|-----|
|비트/바이트|	컴퓨터가 데이터를 저장하는 최소 단위|
|정수 |	2진수, 16진수로 표현 및 저장됨|
|실수 |	IEEE 754로 표현 (정밀도 이슈 주의)|
|문자 |	인코딩된 숫자로 저장됨 (ASCII, EUC-KR, UTF-8 등)|
|Base64 |	이진 데이터 → 문자 인코딩 방식 (웹/네트워크 필수)|